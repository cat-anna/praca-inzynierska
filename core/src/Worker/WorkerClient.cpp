/* 
 *  VisApp source file  
 *
 *  Release version: 1.1 December 2014
 *  File: VisApp/core/src/Worker/WorkerClient.cpp
 *  Author: Paweu
 *  Header Date: Sun Dec  7 18:03:47 GMT 2014
 *
 */
/*--END OF HEADER BLOCK--*/
//Generated by "D:\CommandLine\csrc.bat"

#include "stdafx.h"
#include "WorkerClient.h"
#include "BoostIPCPipe.h"

#include <boost\program_options.hpp>

#include <fstream>

//#include <CoreShared\CoreShared.h>

namespace WorkerClient { 
 
struct eUnknownStatus{};
struct eBrokenStatus{};
struct eCancelledStatus{};
struct eFinishedStatus{};

using namespace boost::program_options;

WorkerClient *Instance = 0;

WorkerClient::WorkerClient() :
		m_Status(ws_New), 
		m_Progress(0), 
		m_InputPipe(0), 
		m_OutputPipe(0),
		m_WorkerThread(0),
		m_WorkerName(L"Unnamed worker"),
		m_PhaseName(L"Unnamed phase"),
		m_Phase(1), 
		m_MaxPhase(1) {
	Instance = this;
}

WorkerClient::~WorkerClient() {
}

xml_node WorkerClient::GetExecutionParameters() const {
	xml_node root = m_ExecutionData.document_element();
	return root.child(WorkerCommands::CommandToString(WorkerCommands::wc_ExecuteWorker));
};

int WorkerClient::WorkerMain(wchar_t* argline) {
	WorkerCommand ExecMode = InitializeClient(argline);
#ifdef  _DEBUG
	SetStatus(ws_DebugWait);
	CheckStatus();
#endif
	SetStatus(ws_Running);
	
	boost::chrono::steady_clock::time_point start = boost::chrono::steady_clock::now();

	try {
		switch (ExecMode) {
		case WorkerCommands::wc_ExecuteWorker: {
				volatile bool IsThreadWorking = true;
				m_WorkerThread = new boost::thread (
					[this, &IsThreadWorking]() { 
						try {
							boost::this_thread::yield();
							CheckStatus();
							RunWorker(); 
							SetProgress(1);
							MessageToSever(WorkerCommands::wc_Finished);
						}
						catch(const std::exception &e) {
					//		LOG << LogType::Critical << e.what();
						}
						catch(...) {
						}
						IsThreadWorking = false;
					});

				boost::this_thread::yield();

				while(IsThreadWorking) ProcessClient();
			}
			break;

		case WorkerCommands::wc_DescribeWorker: {
				xml_document doc;
				xml_node root = doc.append_child(WorkerCommands::CommandToString(WorkerCommands::wc_DescribeWorker));
				DescribeWorker(root);
				//SetStatus(ws_);
				MessageToSever(WorkerCommands::wc_Result, root);
			}
			break;
		default:

			break;
		}
	}
	catch(...) { }
	 
	boost::chrono::duration<double> sec = boost::chrono::steady_clock::now() - start;
	
	//LOG << "Worker '" << m_WorkerName << "' finished in " << sec.count() << " seconds";
	
	return FinalizeClient();
}

void WorkerClient::ProcessClient() {
	if(!m_InputPipe->IsDataWaiting()) {
		SendStatus();
		boost::this_thread::sleep_for(boost::chrono::milliseconds(500));
		return;
	}

	xml_document doc;
	xml_node root = doc.append_child(L"root");
	m_InputPipe->ReadMessage(root);

	xml_node command = root.first_child();
	WorkerCommand wc = WorkerCommands::StringToCommand(command.name());
	switch (wc) {
	case WorkerCommands::wc_Suspend:
		m_Status = ws_Paused;
		break;
	case WorkerCommands::wc_Resume:
		m_Status = ws_Running;
		break;
	case WorkerCommands::wc_Abort:
		m_Status = ws_Cancelled;
		break;		

	case WorkerCommands::wc_Message:
		OnMessage(command.first_child());
		break;		
	case WorkerCommands::wc_Command:
		//OnMessage(command.first_child());
		break;	
	case WorkerCommands::wc_Status:
		//TODO
		break;

	default:
		break;
	}
}

int WorkerClient::OnMessage(const xml_node MessageData) {
	return 0;
}

int WorkerClient::OnCommand(unsigned Command, const xml_node CommandData) {
	return 0;
}



} //namespace WorkerClient
