/* 
 *  VisApp source file  
 *
 *  Release version: 1.1 December 2014
 *  File: VisApp/core/src/Worker/WorkerServer.h
 *  Author: Paweu
 *  Header Date: Sun Dec  7 18:03:47 GMT 2014
 *
 */
/*--END OF HEADER BLOCK--*/
//Generated by "D:\CommandLine\csrc.bat"

#ifndef WorkerServer_H
#define WorkerServer_H

#ifndef BUILDING_WorkerServer

#ifdef BUILD_Debug

#if BUILD_BITS == 32
#pragma comment(lib, "WorkerServer32d.lib")
#else
#pragma comment(lib, "WorkerServer64d.lib")
#endif

#else

#if BUILD_BITS == 32
#pragma comment(lib, "WorkerServer32.lib")
#else
#pragma comment(lib, "WorkerServer64.lib")
#endif

#endif

#endif

#define DefineREADAcces(NAME, TYPE) const TYPE &Get##NAME() const { return m_##NAME; }
#define DefineWRITEAcces(NAME, TYPE) const TYPE &Set##NAME(const TYPE &val) { m_##NAME = val; return val; }
#define DefineRWAcces(NAME, TYPE) TYPE &Get##NAME() { return m_##NAME; }

#include <PugiXML\PugiXML.h>
#include <WorkerClient\MessagePipe.h>
#include <WorkerClient\BoostIPCPipe.h>

namespace WorkerServer { 

using WorkerClient::MessagePipe;

class WorkerServer;

}

#include "WorkerCommands.h"
#include "ProcessTracker.h"
#include "WorkerInstance.h"

namespace WorkerServer { 

class WorkerServer {
public:
	WorkerServer(unsigned QueueSize, unsigned QueueCount);
	~WorkerServer();

	WorkerInstance *CreateInstance(const std::wstring &ExecFile, unsigned RunFlags = ProcessTracker::rf_Default);
	
	xml_node QuerryWorkerDescription(const std::wstring &ExecFile, xml_document &doc);
	bool QuerryWorkerDescriptionAsync(const std::wstring &ExecFile, boost::function<void(xml_node)> DescFunc);

/*	WorkerInstance *GetWorker(unsigned index);
	size_t GetWorkerCount();*/

	void RemoveInstance(WorkerInstance *inst);

	void ProcessInstances();

	xml_node GenerateExecutionXML(xml_document &document, WorkerCommand ExecMode);
protected:

private:
	unsigned m_QueueSize, m_QueueCount;

	std::list<WorkerInstance*> m_Clients;
};

} //namespace WorkerServer

#endif
